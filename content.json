{"meta":{"title":"Deklban的博客","subtitle":"学编程的电气研究僧,将学习和生活中的思考记录于此。","description":"每天都打满鸡血","author":"Delkban","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"002:拨钟问题","slug":"002-拨钟问题","date":"2018-09-12T07:25:17.000Z","updated":"2018-09-12T07:54:20.535Z","comments":true,"path":"2018/09/12/002-拨钟问题/","link":"","permalink":"http://yoursite.com/2018/09/12/002-拨钟问题/","excerpt":"问题还原002: 拨钟问题总时间限制: 1000ms 内存限制: 65536kB 描述有9个时钟，排成一个3*3的矩阵。","text":"问题还原002: 拨钟问题总时间限制: 1000ms 内存限制: 65536kB 描述有9个时钟，排成一个3*3的矩阵。 |-------| |-------| |-------| | | | | | | | |---O | |---O | | O | | | | | | | |-------| |-------| |-------| A B C |-------| |-------| |-------| | | | | | | | O | | O | | O | | | | | | | | | | |-------| |-------| |-------| D E F |-------| |-------| |-------| | | | | | | | O | | O---| | O | | | | | | | | | |-------| |-------| |-------| G H I (图 1) 现在需要用最少的移动，将9个时钟的指针都拨到12点的位置。共允许有9种不同的移动。如下表所示，每个移动会将若干个时钟的指针沿顺时针方向拨动90度。 移动 影响的时钟 1 ABDE 2 ABC 3 BCEF 4 ADG 5 BDEFH 6 CFI 7 DEGH 8 GHI 9 EFHI 输入9个整数，表示各时钟指针的起始位置，相邻两个整数之间用单个空格隔开。其中，0=12点、1=3点、2=6点、3=9点。 输出输出一个最短的移动序列，使得9个时钟的指针都指向12点。按照移动的序号从小到大输出结果。相邻两个整数之间用单个空格隔开。 样例输入3 3 0 2 2 2 2 1 2 样例输出4 5 8 9 解题分析由于问题的规模是固定的，故可以使用暴力穷举的方式进行解题，最多有49个组合，我也是使用的这种方法进行的解题，大的面上很简单，有一个小细节在这里说一下。最后输出的时候，因为每种操作不一定只进行了一次，因此采用下列语句输出： 123for (cur = 0; cur &lt; 9; cur++) while (move_count[cur]--) cout&lt;&lt;cur + 1&lt;&lt;&quot; &quot;; 另外还有一一种做法就是类似于之前的熄灯问题和密码锁问题，找到一个局部，然后顺次分析。 对方法1,2,3进行枚举，每种方法实施0–3次，共43种情况。如果我们确定了1,2,3的情况属，则将得到灯A,B,C的状态，而只有移动4能够改变A，移动5能够改变B，移动6能够改变C，那么移动4–6的次数也确定了。同样的，这时只有移动7能够改变D，移动9能够改变F，这时移动7和9的次数也确定了。最后，时钟ABCDF都已经符合要求，EGHI还没有确定，剩下的只有移动8能够改变GHI，所以只要检查E是否已经达到要求并且GHI的时钟数是否相等即可。最后找到最小移动次数即可。 代码实现我只使用暴力枚举进行了实现，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int oriState[9] = &#123;0&#125;; for (int i = 0; i &lt; 9; i++) cin&gt;&gt;oriState[i]; int move_count[9] = &#123;0&#125;; int min_count = 99; for (int i1 = 0; i1 &lt; 4; i1++) for (int i2 = 0; i2 &lt; 4; i2++) for (int i3 = 0; i3 &lt; 4; i3++) for (int i4 = 0; i4 &lt; 4; i4++) for (int i5 = 0; i5 &lt; 4; i5++) for (int i6 = 0; i6 &lt; 4; i6++) for (int i7 = 0; i7 &lt; 4; i7++) for (int i8 = 0; i8 &lt; 4; i8++) for (int i9 = 0; i9 &lt; 4; i9++) &#123; if ((0 == (i1 + i2 + i4 + oriState[0]) % 4) &amp;&amp; (0 == (i1 + i2 + i3 + i5 + oriState[1]) % 4) &amp;&amp; (0 == (i2 + i3 + i6 + oriState[2]) % 4) &amp;&amp; (0 == (i1 + i4 + i5 + i7 + oriState[3]) % 4) &amp;&amp; (0 == (i1 + i3 + i5 + i7 + i9 + oriState[4]) % 4) &amp;&amp; (0 == (i3 + i5 + i6 + i9 + oriState[5])% 4) &amp;&amp; (0 == (i4 + i7 + i8 + oriState[6]) % 4) &amp;&amp; (0 == (i5 + i7 + i8 + i9 + oriState[7])% 4) &amp;&amp; (0 == (i6 + i8 + i9 + oriState[8]) % 4)) &#123; int sum = i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9; if (min_count &gt; sum) &#123; min_count = sum; move_count[0] = i1; move_count[1] = i2; move_count[2] = i3; move_count[3] = i4; move_count[4] = i5; move_count[5] = i6; move_count[6] = i7; move_count[7] = i8; move_count[8] = i9; &#125; &#125; &#125; int cur = 0; for (cur = 0; cur &lt; 9; cur++) while (move_count[cur]--) cout&lt;&lt;cur + 1&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"枚举","slug":"枚举","permalink":"http://yoursite.com/tags/枚举/"}]},{"title":"用new运算符实现动态内存分配","slug":"C-动态内存分配","date":"2018-09-12T04:05:45.000Z","updated":"2018-09-12T04:46:55.018Z","comments":true,"path":"2018/09/12/C-动态内存分配/","link":"","permalink":"http://yoursite.com/2018/09/12/C-动态内存分配/","excerpt":"用法用法一：分配一个变量P = new T; 其中T是任意类型名，P是类型为T*的指针。","text":"用法用法一：分配一个变量P = new T; 其中T是任意类型名，P是类型为T*的指针。动态分配出一片大小为sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。比如： 123int * pn;pn = new int;* pn = 5; 上述初始化语句也可以合为一个： int * pn = new int ; 用法二：分配一个数组P = new T[N] T：任意类型名 P：类型为T*的指针 N：要分配的数组元素的个数，可以是整型表达式 动态分配出一片大小为sizeof(T)*N字节的内存空间，并且将该内存空间的起始地址赋值给p。 一定要用delete运算符释放空间用 new 动态分配的内存空间，一定要用 delete 运算符进行释放 delete 指针： 必须指向new出来的空间 1234int * p =new int;* p = 5;delete p;delete p; //将会导致异常，一片空间不能被delete多次 用delete释放动态分配的数组，要加”[]”： 123int * p =new int[20];p[0] = 1;delete [] p; 例题：神秘的数组初始化描述填空，使得程序输出指定结果 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main()&#123; int * a[] = &#123;// 在此处补充你的代码&#125;; *a[2] = 123; a[3][5] = 456; if(! a[0] ) &#123; cout &lt;&lt; * a[2] &lt;&lt; &quot;,&quot; &lt;&lt; a[3][5]; &#125; return 0;&#125; 输入无 输出123,456 分析int * a[]是定义了一个指针数组，即数组中存放的都是指针*a[2] = 123;实际上是取了存放在a[2]中的地址的内容，因此数组在第三个位置处只需要1个量来存放地址，而前两个用不到，设为NULLa[3][5] =456；可以理解为在数组a的第4个位置需要6个空间，因此需要new int[6] 答案初始化语句为: int * a[] = {NULL, NULL, new int[1], new int[6]}","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"001：特殊密码锁","slug":"枚举（一）特殊密码锁","date":"2018-09-11T09:28:33.000Z","updated":"2018-09-12T07:32:09.540Z","comments":true,"path":"2018/09/11/枚举（一）特殊密码锁/","link":"","permalink":"http://yoursite.com/2018/09/11/枚举（一）特殊密码锁/","excerpt":"问题还原001:特殊密码锁总时间限制: 1000ms 内存限制: 1024kB","text":"问题还原001:特殊密码锁总时间限制: 1000ms 内存限制: 1024kB 描述有一种特殊的二进制密码锁，由n个相连的按钮组成（n&lt;30），按钮有凹/凸两种状态，用手按按钮会改变其状态。 然而让人头疼的是，当你按一个按钮时，跟它相邻的两个按钮状态也会反转。当然，如果你按的是最左或者最右边的按钮，该按钮只会影响到跟它相邻的一个按钮。 当前密码锁状态已知，需要解决的问题是，你至少需要按多少次按钮，才能将密码锁转变为所期望的目标状态。 输入两行，给出两个由0、1组成的等长字符串，表示当前/目标密码锁状态，其中0代表凹，1代表凸。 输出至少需要进行的按按钮操作次数，如果无法实现转变，则输出impossible。 样例输入1011 000 样例输出11 样例输入201 11 样例输出2impossible 解题分析考虑使用枚举法解题，但是如果使用暴力穷举，将会产生2n次循环，在n接近30的时候，必然无法满足时间限制。 事实上，在使用枚举法的时候往往可以考虑一些最小结构。 例如，在熄灯问题中，给定一个固定大小的 0 1 矩阵，0代表熄灯，1代表亮灯，每个灯的开关都可以操作，每个开关都会使其本身及上下左右共五个块的数据产生翻转，若在边界处，其影响范围将对应减少。题目要求输出能将给定的矩阵变成全零矩阵的开关操作矩阵，简单的说就是把对应开关的操作写成矩阵，按开关就是1，不按开关就是0。 这个问题如果进行穷举的话将会更快的达到时间上线。 仔细观察可以发现，如果第一行灯的操作确定了，那么在进行第二行操作的时候，为了保证第一行一定是正确的，那么第二行的操作也将是确定的，如此循环下去，到达最后一行，只需要检查最后一行能否达到全零的目标即可。因此熄灯问题中，第一行就是最小结构。 回到密码锁的问题，这其实是对熄灯问题的一个简化。假设我们按照从左到右的顺序进行操作，如果给定了第一个按钮的状态，那么为了保证第一个按钮保持和目标的一致，第二个按钮的操作也将是确定的，这样循环下去，通过第n-1个按钮的状态确定了最后一个按钮的操作之后，只需要对比最后一个按钮和目标的最后一个按钮的状态就可以了。因此只需要对第一个按钮的状态进行枚举，只需要进行两次枚举即可。这样就解决了时间复杂度的问题。 代码实现中的几个关键部分 输入的两个量作为字符串变量进行存储： 123string ini,aim;getline(cin,ini);getline(cin,aim); 在这种输入下，字符串的长度测量使用，其中不包含最后的’\\0’ int len = ini.size(); 数据的存储可以使用数组，但是为了减少代码的空间复杂度，可以使用位运算的方法来提高效率。主要的操作如下： 将变量c的第i位置为v，其中v只能是0或1： 1234567891011void SetBit(int &amp;c, int i,char v) &#123;if(v == &apos;1&apos;)&#123;c |= (1 &lt;&lt; i);&#125;else if (v == &apos;0&apos;)&#123;c &amp;= ~(1 &lt;&lt; i);&#125;&#125; 取变量c的第i位： 1234int GetBit(int c,int i)//取c的第i位&#123;return(c &gt;&gt; i) &amp; 1;&#125; 翻转c的第i位 1234void FlipBit(int &amp;c,int i)&#123; c ^= (1 &lt;&lt; i);&#125; 不要忘记当不能正常输出时要输出异常报告：impossible. 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int iniState;//存放原始状态int aimState;//存放目标状态int mixCount =999; //存放最小计数 int GetBit(int c,int i)//取c的第i位&#123; return(c &gt;&gt; i) &amp; 1; &#125; //设置c的第i位为v void SetBit(int &amp;c, int i,char v) &#123; if(v == &apos;1&apos;)&#123; c |= (1 &lt;&lt; i); &#125; else if (v == &apos;0&apos;) &#123; c &amp;= ~(1 &lt;&lt; i); &#125;&#125;//翻转c的第i位void FlipBit(int &amp;c, int i)&#123; c ^= (1 &lt;&lt; i);&#125; int main()&#123; string ini,aim; getline(cin,ini); getline(cin,aim); int len = ini.size(); //len为输入的数据的长度 int count=0,mixCount=999; //计算次数、最小计算次数 for (int i = 0;i&lt;len;i++) //改为位表示 &#123; SetBit(iniState,i,ini[i]); SetBit(aimState,i,aim[i]); &#125; for(int n = 0; n &lt; 2; n++) //枚举开头的两种可能 &#123; int state = iniState; int count = 0; int flag = n;//初始化标志位，1变0不变 if(n)&#123; FlipBit(state,0); //处理第一个数据 FlipBit(state,1);//第二个数据也要翻转 count ++ ; &#125; for(int i = 1; i &lt; len; i++) &#123; if(GetBit(state,i-1) == GetBit(aimState,i-1))//若上个数据和目标一致，则flag为0 flag = 0; else flag = 1; if(flag == 1) //需翻转 &#123; count ++ ; FlipBit(state,i); //翻转当前位 if(i != len-1) FlipBit(state,i+1); //未到边界，翻转下一位。 //上一位不需要操作，只需对比最后一位即可 &#125; &#125; //如果末位不一样，说明不可行，count置零 if(GetBit(state,len-1) != GetBit(aimState,len-1)) count = 0; if (count != 0) &#123; if(count &lt; mixCount) mixCount = count; &#125; &#125; if(mixCount != 999) cout &lt;&lt; mixCount &lt;&lt;endl; else cout &lt;&lt; &quot;impossible&quot;&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"枚举","slug":"枚举","permalink":"http://yoursite.com/tags/枚举/"}]},{"title":"我的第一篇博客暨开学日","slug":"我的第一篇博客","date":"2018-09-10T13:33:43.000Z","updated":"2018-09-11T01:10:42.933Z","comments":true,"path":"2018/09/10/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2018/09/10/我的第一篇博客/","excerpt":"个人博客初长成经过一番折腾，我的个人博客终于算是搭建起来了，虽然还有很多问题，但是起码能够记录和发布了。这里主要用来记录我学习过程中遇到的问题，有时候也会用来写一些自己的思考，内容可能会比较杂乱。 做个人博客的主要目的也是想提醒自己，不要安于现状，停留在自己的舒适区，要积极的去思考问题和解决问题，热情的学习语言工具并进行练习。当然，这也是我学习过程的一个见证，如果我能坚持下去，将来再回顾相关的知识也会更加方便。","text":"个人博客初长成经过一番折腾，我的个人博客终于算是搭建起来了，虽然还有很多问题，但是起码能够记录和发布了。这里主要用来记录我学习过程中遇到的问题，有时候也会用来写一些自己的思考，内容可能会比较杂乱。 做个人博客的主要目的也是想提醒自己，不要安于现状，停留在自己的舒适区，要积极的去思考问题和解决问题，热情的学习语言工具并进行练习。当然，这也是我学习过程的一个见证，如果我能坚持下去，将来再回顾相关的知识也会更加方便。 开学第一天今天是正式开学的第一天，其实从前天报道的时候我就没有什么感觉，经历过了二战，经历过了陪栗子小姐找工作，我对未来的方向有了大概的定夺，对接下来我要做的事情也越发的清晰了。我会在完成教学计划里面的任务之外再修好慕课中的语言课、算法课，以及吴恩达的机器学习课，在完成老师给的任务之外，还要保证每天的代码量。 其实做计划，定任务这种事情已经做了很多年了，但是往往是半途而废，有始无终。但我觉着这次自己和以前不太一样了，我坚持看了以前很反感抽象的位操作程序，接触并且开始使用GitHub，而不是只停留在“在知乎上看过”，我还搭建了属于自己的博客，并计划以后长期更新。 开端是好的，剩下最难的便是坚持了。 日常安排今天开会确定了以后上课时在工作日上，那么之前完整的时间将会被冲散，考虑到通勤时间的问题，其实留给我学习别的知识的时间并不是太多，更遑论任郡枝学长还建议好好学习，争取考高分，毕竟学长说了 虽然不能评奖，但和自身相关的东西总是有价值的，不会白学的。 那么我给自己大概的安排是这样的： 保证吸收上课过程中有用的知识，尽量做到跟上课的进度 跟住姥姥的数据结构与算法课、翁恺老师的JAVA课、郭老师的程序二&amp;三，认真完成作业，争取拿到证书。 尽量跟住大数据、计算机网络、数据库和软件工程导论，学不过来可以适当放弃。 接下来一个月主要还是打语言基础，机器学习课程暂时不开。 偶尔搜索一下深度学习 &amp; 系统可靠性相关的论文，考虑论文方向。 其实最关键的还是要坚持，坚持每天的规律作息，坚守自己内心的信念。 我已经准备好了，开始出发吧。 特别鸣谢送花花给我最爱的栗子小姐，如果没有你，一切努力又有何意义。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"DelkBan测试","slug":"DelkBan测试文章","date":"2018-09-09T12:53:50.137Z","updated":"2018-09-11T01:11:15.483Z","comments":true,"path":"2018/09/09/DelkBan测试文章/","link":"","permalink":"http://yoursite.com/2018/09/09/DelkBan测试文章/","excerpt":"`printf(&quot;Hello World!&quot;);`","text":"`printf(&quot;Hello World!&quot;);` 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章 测试文章测试文章测试文章测试文章测试文章测试文章测试文章测试文章","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-09-09T12:21:52.620Z","updated":"2018-09-09T12:21:52.621Z","comments":true,"path":"2018/09/09/hello-world/","link":"","permalink":"http://yoursite.com/2018/09/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}